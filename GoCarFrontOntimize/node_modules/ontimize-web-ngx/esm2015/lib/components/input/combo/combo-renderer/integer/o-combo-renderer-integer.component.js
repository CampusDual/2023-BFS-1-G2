import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, Injector, TemplateRef, ViewChild } from '@angular/core';
import { InputConverter } from '../../../../../decorators/input-converter';
import { OIntegerPipe } from '../../../../../pipes/o-integer.pipe';
import { DEFAULT_INPUTS_O_COMBO_RENDERER, OComboCustomRenderer } from '../o-combo-renderer.class';
export const DEFAULT_INPUTS_O_COMBO_RENDERER_INTEGER = [
    ...DEFAULT_INPUTS_O_COMBO_RENDERER,
    'grouping',
    'thousandSeparator: thousand-separator'
];
export class OComboRendererIntegerComponent extends OComboCustomRenderer {
    constructor(injector) {
        super(injector);
        this.injector = injector;
        this.grouping = true;
        this.thousandSeparator = ',';
        this.setComponentPipe();
    }
    setComponentPipe() {
        this.componentPipe = new OIntegerPipe(this.injector);
    }
    initialize() {
        super.initialize();
        this.pipeArguments = {
            grouping: this.grouping,
            thousandSeparator: this.thousandSeparator
        };
    }
}
OComboRendererIntegerComponent.decorators = [
    { type: Component, args: [{
                selector: 'o-combo-renderer-integer',
                template: "<ng-template #templateref let-value=\"value\">\n  {{getComboData(value)}}\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: DEFAULT_INPUTS_O_COMBO_RENDERER_INTEGER
            }] }
];
OComboRendererIntegerComponent.ctorParameters = () => [
    { type: Injector }
];
OComboRendererIntegerComponent.propDecorators = {
    templateref: [{ type: ViewChild, args: ['templateref', { read: TemplateRef, static: true },] }]
};
tslib_1.__decorate([
    InputConverter(),
    tslib_1.__metadata("design:type", Boolean)
], OComboRendererIntegerComponent.prototype, "grouping", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiby1jb21iby1yZW5kZXJlci1pbnRlZ2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL29udGltaXplLXdlYi1uZ3gvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9pbnB1dC9jb21iby9jb21iby1yZW5kZXJlci9pbnRlZ2VyL28tY29tYm8tcmVuZGVyZXItaW50ZWdlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFFBQVEsRUFFUixXQUFXLEVBQ1gsU0FBUyxFQUNWLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUMzRSxPQUFPLEVBQXdCLFlBQVksRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQ3pGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRWxHLE1BQU0sQ0FBQyxNQUFNLHVDQUF1QyxHQUFHO0lBQ3JELEdBQUcsK0JBQStCO0lBRWxDLFVBQVU7SUFFVix1Q0FBdUM7Q0FDeEMsQ0FBQztBQVFGLE1BQU0sT0FBTyw4QkFBK0IsU0FBUSxvQkFBb0I7SUFVdEUsWUFBc0IsUUFBa0I7UUFDdEMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBREksYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQVA5QixhQUFRLEdBQVksSUFBSSxDQUFDO1FBQ3pCLHNCQUFpQixHQUFXLEdBQUcsQ0FBQztRQVF4QyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQsZ0JBQWdCO1FBQ2QsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELFVBQVU7UUFDUixLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbkIsSUFBSSxDQUFDLGFBQWEsR0FBRztZQUNuQixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGlCQUFpQjtTQUMxQyxDQUFDO0lBQ0osQ0FBQzs7O1lBL0JGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsMEJBQTBCO2dCQUNwQyx1R0FBd0Q7Z0JBQ3hELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxNQUFNLEVBQUUsdUNBQXVDO2FBQ2hEOzs7WUF2QkMsUUFBUTs7OzBCQWdDUCxTQUFTLFNBQUMsYUFBYSxFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFOztBQUw3RDtJQURDLGNBQWMsRUFBRTs7Z0VBQ2tCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgSW5qZWN0b3IsXG4gIE9uSW5pdCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSW5wdXRDb252ZXJ0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9kZWNvcmF0b3JzL2lucHV0LWNvbnZlcnRlcic7XG5pbXBvcnQgeyBJSW50ZWdlclBpcGVBcmd1bWVudCwgT0ludGVnZXJQaXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vcGlwZXMvby1pbnRlZ2VyLnBpcGUnO1xuaW1wb3J0IHsgREVGQVVMVF9JTlBVVFNfT19DT01CT19SRU5ERVJFUiwgT0NvbWJvQ3VzdG9tUmVuZGVyZXIgfSBmcm9tICcuLi9vLWNvbWJvLXJlbmRlcmVyLmNsYXNzJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSU5QVVRTX09fQ09NQk9fUkVOREVSRVJfSU5URUdFUiA9IFtcbiAgLi4uREVGQVVMVF9JTlBVVFNfT19DT01CT19SRU5ERVJFUixcbiAgLy8gZ3JvdXBpbmcgW25vfHllc106IGdyb3VwaW5nIHRob3VzYW5kcy4gRGVmYXVsdDogeWVzLlxuICAnZ3JvdXBpbmcnLFxuICAvLyB0aG91c2FuZC1zZXBhcmF0b3IgW3N0cmluZ106IHRob3VzYW5kcyBzZXBhcmF0b3Igd2hlbiBncm91cGluZy4gRGVmYXVsdDogY29tbWEgKCwpLlxuICAndGhvdXNhbmRTZXBhcmF0b3I6IHRob3VzYW5kLXNlcGFyYXRvcidcbl07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ28tY29tYm8tcmVuZGVyZXItaW50ZWdlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9vLWNvbWJvLXJlbmRlcmVyLWludGVnZXIuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgaW5wdXRzOiBERUZBVUxUX0lOUFVUU19PX0NPTUJPX1JFTkRFUkVSX0lOVEVHRVJcbn0pXG5leHBvcnQgY2xhc3MgT0NvbWJvUmVuZGVyZXJJbnRlZ2VyQ29tcG9uZW50IGV4dGVuZHMgT0NvbWJvQ3VzdG9tUmVuZGVyZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkluaXQge1xuXG4gIEBJbnB1dENvbnZlcnRlcigpXG4gIHByb3RlY3RlZCBncm91cGluZzogYm9vbGVhbiA9IHRydWU7XG4gIHByb3RlY3RlZCB0aG91c2FuZFNlcGFyYXRvcjogc3RyaW5nID0gJywnO1xuICBwcm90ZWN0ZWQgY29tcG9uZW50UGlwZTogT0ludGVnZXJQaXBlO1xuICBwcm90ZWN0ZWQgcGlwZUFyZ3VtZW50czogSUludGVnZXJQaXBlQXJndW1lbnQ7XG5cbiAgQFZpZXdDaGlsZCgndGVtcGxhdGVyZWYnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSkgcHVibGljIHRlbXBsYXRlcmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICBzdXBlcihpbmplY3Rvcik7XG4gICAgdGhpcy5zZXRDb21wb25lbnRQaXBlKCk7XG4gIH1cblxuICBzZXRDb21wb25lbnRQaXBlKCkge1xuICAgIHRoaXMuY29tcG9uZW50UGlwZSA9IG5ldyBPSW50ZWdlclBpcGUodGhpcy5pbmplY3Rvcik7XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLnBpcGVBcmd1bWVudHMgPSB7XG4gICAgICBncm91cGluZzogdGhpcy5ncm91cGluZyxcbiAgICAgIHRob3VzYW5kU2VwYXJhdG9yOiB0aGlzLnRob3VzYW5kU2VwYXJhdG9yXG4gICAgfTtcbiAgfVxuXG59XG4iXX0=