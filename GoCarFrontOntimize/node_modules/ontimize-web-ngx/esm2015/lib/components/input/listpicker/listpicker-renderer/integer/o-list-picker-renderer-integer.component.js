import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, Injector, TemplateRef, ViewChild } from '@angular/core';
import { InputConverter } from '../../../../../decorators/input-converter';
import { OIntegerPipe } from '../../../../../pipes/o-integer.pipe';
import { DEFAULT_INPUTS_O_LISTPICKER_RENDERER, OListPickerCustomRenderer } from '../o-list-picker-renderer.class';
export const DEFAULT_INPUTS_O_LISTPICKER_RENDERER_INTEGER = [
    ...DEFAULT_INPUTS_O_LISTPICKER_RENDERER,
    'grouping',
    'thousandSeparator: thousand-separator'
];
export class OListPickerRendererIntegerComponent extends OListPickerCustomRenderer {
    constructor(injector) {
        super(injector);
        this.injector = injector;
        this.grouping = true;
        this.thousandSeparator = ',';
        this.setComponentPipe();
    }
    setComponentPipe() {
        this.componentPipe = new OIntegerPipe(this.injector);
    }
    initialize() {
        super.initialize();
        this.pipeArguments = {
            grouping: this.grouping,
            thousandSeparator: this.thousandSeparator
        };
    }
}
OListPickerRendererIntegerComponent.decorators = [
    { type: Component, args: [{
                selector: 'o-list-picker-renderer-integer',
                template: "<ng-template #templateref let-value=\"value\">\n  {{getListPickerValue(value)}}\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                inputs: DEFAULT_INPUTS_O_LISTPICKER_RENDERER_INTEGER
            }] }
];
OListPickerRendererIntegerComponent.ctorParameters = () => [
    { type: Injector }
];
OListPickerRendererIntegerComponent.propDecorators = {
    templateref: [{ type: ViewChild, args: ['templateref', { read: TemplateRef, static: true },] }]
};
tslib_1.__decorate([
    InputConverter(),
    tslib_1.__metadata("design:type", Boolean)
], OListPickerRendererIntegerComponent.prototype, "grouping", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiby1saXN0LXBpY2tlci1yZW5kZXJlci1pbnRlZ2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL29udGltaXplLXdlYi1uZ3gvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9pbnB1dC9saXN0cGlja2VyL2xpc3RwaWNrZXItcmVuZGVyZXIvaW50ZWdlci9vLWxpc3QtcGlja2VyLXJlbmRlcmVyLWludGVnZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxRQUFRLEVBRVIsV0FBVyxFQUNYLFNBQVMsRUFDVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDM0UsT0FBTyxFQUF3QixZQUFZLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN6RixPQUFPLEVBQUUsb0NBQW9DLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUVsSCxNQUFNLENBQUMsTUFBTSw0Q0FBNEMsR0FBRztJQUMxRCxHQUFHLG9DQUFvQztJQUV2QyxVQUFVO0lBRVYsdUNBQXVDO0NBQ3hDLENBQUM7QUFRRixNQUFNLE9BQU8sbUNBQW9DLFNBQVEseUJBQXlCO0lBVWhGLFlBQXNCLFFBQWtCO1FBQ3RDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQURJLGFBQVEsR0FBUixRQUFRLENBQVU7UUFQOUIsYUFBUSxHQUFZLElBQUksQ0FBQztRQUN6QixzQkFBaUIsR0FBVyxHQUFHLENBQUM7UUFReEMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVELGdCQUFnQjtRQUNkLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxVQUFVO1FBQ1IsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ25CLElBQUksQ0FBQyxhQUFhLEdBQUc7WUFDbkIsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLGlCQUFpQixFQUFFLElBQUksQ0FBQyxpQkFBaUI7U0FDMUMsQ0FBQztJQUNKLENBQUM7OztZQS9CRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGdDQUFnQztnQkFDMUMsNkdBQThEO2dCQUM5RCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsTUFBTSxFQUFFLDRDQUE0QzthQUNyRDs7O1lBdkJDLFFBQVE7OzswQkFnQ1AsU0FBUyxTQUFDLGFBQWEsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs7QUFMN0Q7SUFEQyxjQUFjLEVBQUU7O3FFQUNrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEluamVjdG9yLFxuICBPbkluaXQsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IElucHV0Q29udmVydGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZGVjb3JhdG9ycy9pbnB1dC1jb252ZXJ0ZXInO1xuaW1wb3J0IHsgSUludGVnZXJQaXBlQXJndW1lbnQsIE9JbnRlZ2VyUGlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3BpcGVzL28taW50ZWdlci5waXBlJztcbmltcG9ydCB7IERFRkFVTFRfSU5QVVRTX09fTElTVFBJQ0tFUl9SRU5ERVJFUiwgT0xpc3RQaWNrZXJDdXN0b21SZW5kZXJlciB9IGZyb20gJy4uL28tbGlzdC1waWNrZXItcmVuZGVyZXIuY2xhc3MnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9JTlBVVFNfT19MSVNUUElDS0VSX1JFTkRFUkVSX0lOVEVHRVIgPSBbXG4gIC4uLkRFRkFVTFRfSU5QVVRTX09fTElTVFBJQ0tFUl9SRU5ERVJFUixcbiAgLy8gZ3JvdXBpbmcgW25vfHllc106IGdyb3VwaW5nIHRob3VzYW5kcy4gRGVmYXVsdDogeWVzLlxuICAnZ3JvdXBpbmcnLFxuICAvLyB0aG91c2FuZC1zZXBhcmF0b3IgW3N0cmluZ106IHRob3VzYW5kcyBzZXBhcmF0b3Igd2hlbiBncm91cGluZy4gRGVmYXVsdDogY29tbWEgKCwpLlxuICAndGhvdXNhbmRTZXBhcmF0b3I6IHRob3VzYW5kLXNlcGFyYXRvcidcbl07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ28tbGlzdC1waWNrZXItcmVuZGVyZXItaW50ZWdlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9vLWxpc3QtcGlja2VyLXJlbmRlcmVyLWludGVnZXIuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgaW5wdXRzOiBERUZBVUxUX0lOUFVUU19PX0xJU1RQSUNLRVJfUkVOREVSRVJfSU5URUdFUlxufSlcbmV4cG9ydCBjbGFzcyBPTGlzdFBpY2tlclJlbmRlcmVySW50ZWdlckNvbXBvbmVudCBleHRlbmRzIE9MaXN0UGlja2VyQ3VzdG9tUmVuZGVyZXIgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkluaXQge1xuXG4gIEBJbnB1dENvbnZlcnRlcigpXG4gIHByb3RlY3RlZCBncm91cGluZzogYm9vbGVhbiA9IHRydWU7XG4gIHByb3RlY3RlZCB0aG91c2FuZFNlcGFyYXRvcjogc3RyaW5nID0gJywnO1xuICBwcm90ZWN0ZWQgY29tcG9uZW50UGlwZTogT0ludGVnZXJQaXBlO1xuICBwcm90ZWN0ZWQgcGlwZUFyZ3VtZW50czogSUludGVnZXJQaXBlQXJndW1lbnQ7XG5cbiAgQFZpZXdDaGlsZCgndGVtcGxhdGVyZWYnLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IHRydWUgfSkgcHVibGljIHRlbXBsYXRlcmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICBzdXBlcihpbmplY3Rvcik7XG4gICAgdGhpcy5zZXRDb21wb25lbnRQaXBlKCk7XG4gIH1cblxuICBzZXRDb21wb25lbnRQaXBlKCkge1xuICAgIHRoaXMuY29tcG9uZW50UGlwZSA9IG5ldyBPSW50ZWdlclBpcGUodGhpcy5pbmplY3Rvcik7XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLnBpcGVBcmd1bWVudHMgPSB7XG4gICAgICBncm91cGluZzogdGhpcy5ncm91cGluZyxcbiAgICAgIHRob3VzYW5kU2VwYXJhdG9yOiB0aGlzLnRob3VzYW5kU2VwYXJhdG9yXG4gICAgfTtcbiAgfVxuXG59XG4iXX0=