import { SelectionModel } from '@angular/cdk/collections';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Inject, Injector, ViewChild } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialogRef, MatSelectionList } from '@angular/material';
import { DialogService } from '../../../../services/dialog.service';
var OLoadFilterDialogComponent = (function () {
    function OLoadFilterDialogComponent(dialogRef, data, injector) {
        this.dialogRef = dialogRef;
        this.injector = injector;
        this.filters = [];
        this.onDelete = new EventEmitter();
        this.loadFilters(data);
        this.dialogService = this.injector.get(DialogService);
        try {
            this.cd = this.injector.get(ChangeDetectorRef);
        }
        catch (e) {
        }
    }
    OLoadFilterDialogComponent.prototype.ngOnInit = function () {
        this.filterList.selectedOptions = new SelectionModel(false);
    };
    OLoadFilterDialogComponent.prototype.loadFilters = function (filters) {
        this.filters = filters;
    };
    OLoadFilterDialogComponent.prototype.getSelectedFilterName = function () {
        var selected = this.filterList.selectedOptions.selected;
        return selected.length ? selected[0].value : void 0;
    };
    OLoadFilterDialogComponent.prototype.removeFilter = function (filterName) {
        var _this = this;
        this.dialogService.confirm('CONFIRM', 'TABLE.DIALOG.CONFIRM_REMOVE_FILTER').then(function (result) {
            if (result) {
                _this.onDelete.emit(filterName);
                _this.cd.detectChanges();
            }
        });
    };
    OLoadFilterDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'o-load-filter-dialog',
                    template: "<span mat-dialog-title>{{ 'TABLE.BUTTONS.FILTER_LOAD' | oTranslate }}</span>\n<mat-dialog-content fxLayout=\"column\">\n  <div mat-subheader>{{ 'TABLE.DIALOG.LOAD_FILTER' | oTranslate }}</div>\n  <mat-selection-list #filterList dense class=\"o-table-load-filter-dialog-list\">\n    <mat-list-option *ngFor=\"let filter of filters \" [value]=\"filter.name\" checkboxPosition=\"before\">\n      <span matLine class=\"o-table-load-filter-dialog-list-title\">{{ filter.name }}</span>\n      <span matLine>{{ filter.description }}</span>\n    </mat-list-option>\n    <mat-list-item *ngIf=\"filters.length === 0\">\n      <span class=\"empty-filter-list\">{{ 'TABLE.DIALOG.EMPTY_FILTER_LIST' | oTranslate }}</span>\n    </mat-list-item>\n  </mat-selection-list>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n  <button type=\"button\" mat-stroked-button [disabled]=\"filterList.selectedOptions.selected.length!==1\"\n    (click)=\"removeFilter(filterList.selectedOptions.selected[0].value)\" class=\"o-button-danger\">{{ 'DELETE' | oTranslate }}</button>\n  <span fxFlex></span>\n  <button type=\"button\" mat-stroked-button [mat-dialog-close]=\"false\" class=\"o-button-default cancel\">{{ 'CANCEL' | oTranslate }}</button>\n  <button type=\"button\" mat-stroked-button [mat-dialog-close]=\"true\" [disabled]=\"filterList.selectedOptions.selected.length!==1\"\n    class=\"o-button-primary\">\n    {{'TABLE.BUTTONS.APPLY' | oTranslate }}\n  </button>\n</mat-dialog-actions>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    OLoadFilterDialogComponent.ctorParameters = function () { return [
        { type: MatDialogRef },
        { type: Array, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
        { type: Injector }
    ]; };
    OLoadFilterDialogComponent.propDecorators = {
        filterList: [{ type: ViewChild, args: [MatSelectionList, { static: true },] }]
    };
    return OLoadFilterDialogComponent;
}());
export { OLoadFilterDialogComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiby1sb2FkLWZpbHRlci1kaWFsb2cuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vb250aW1pemUtd2ViLW5neC8iLCJzb3VyY2VzIjpbImxpYi9zaGFyZWQvY29tcG9uZW50cy9maWx0ZXIvbG9hZC1maWx0ZXIvby1sb2FkLWZpbHRlci1kaWFsb2cuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsWUFBWSxFQUNaLE1BQU0sRUFDTixRQUFRLEVBR1IsU0FBUyxFQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxlQUFlLEVBQUUsWUFBWSxFQUFpQixnQkFBZ0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRW5HLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUdwRTtJQWdCRSxvQ0FDUyxTQUFtRCxFQUNqQyxJQUEyQixFQUMxQyxRQUFrQjtRQUZyQixjQUFTLEdBQVQsU0FBUyxDQUEwQztRQUVoRCxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBVjlCLFlBQU8sR0FBMEIsRUFBRSxDQUFDO1FBRXBDLGFBQVEsR0FBeUIsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQVVsRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQWdCLGFBQW9DLENBQUMsQ0FBQztRQUM1RixJQUFJO1lBQ0YsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBb0IsaUJBQTRDLENBQUMsQ0FBQztTQUM5RjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1NBRVg7SUFDSCxDQUFDO0lBRUQsNkNBQVEsR0FBUjtRQUNFLElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxHQUFHLElBQUksY0FBYyxDQUFnQixLQUFLLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRUQsZ0RBQVcsR0FBWCxVQUFZLE9BQThCO1FBQ3hDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0lBQ3pCLENBQUM7SUFFRCwwREFBcUIsR0FBckI7UUFDRSxJQUFNLFFBQVEsR0FBb0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDO1FBQzNFLE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELGlEQUFZLEdBQVosVUFBYSxVQUFrQjtRQUEvQixpQkFPQztRQU5DLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxvQ0FBb0MsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFBLE1BQU07WUFDckYsSUFBSSxNQUFNLEVBQUU7Z0JBQ1YsS0FBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQy9CLEtBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7YUFDekI7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7O2dCQWxERixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLHNCQUFzQjtvQkFDaEMseTlDQUFvRDtvQkFDcEQsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEOzs7Z0JBVHlCLFlBQVk7NENBdUJqQyxNQUFNLFNBQUMsZUFBZTtnQkE1QnpCLFFBQVE7Ozs2QkFpQlAsU0FBUyxTQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs7SUE2Qy9DLGlDQUFDO0NBQUEsQUFwREQsSUFvREM7U0EvQ1ksMEJBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2VsZWN0aW9uTW9kZWwgfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgT25Jbml0LFxuICBUeXBlLFxuICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNQVRfRElBTE9HX0RBVEEsIE1hdERpYWxvZ1JlZiwgTWF0TGlzdE9wdGlvbiwgTWF0U2VsZWN0aW9uTGlzdCB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcblxuaW1wb3J0IHsgRGlhbG9nU2VydmljZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZpY2VzL2RpYWxvZy5zZXJ2aWNlJztcbmltcG9ydCB7IE9UYWJsZUZpbHRlcnNTdGF0dXMgfSBmcm9tICcuLi8uLi8uLi8uLi90eXBlcy90YWJsZS9vLXRhYmxlLWZpbHRlci1zdGF0dXMudHlwZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ28tbG9hZC1maWx0ZXItZGlhbG9nJyxcbiAgdGVtcGxhdGVVcmw6ICcuL28tbG9hZC1maWx0ZXItZGlhbG9nLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgT0xvYWRGaWx0ZXJEaWFsb2dDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIEBWaWV3Q2hpbGQoTWF0U2VsZWN0aW9uTGlzdCwgeyBzdGF0aWM6IHRydWUgfSkgZmlsdGVyTGlzdDogTWF0U2VsZWN0aW9uTGlzdDtcblxuICBmaWx0ZXJzOiBPVGFibGVGaWx0ZXJzU3RhdHVzW10gPSBbXTtcblxuICBvbkRlbGV0ZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgcHJvdGVjdGVkIGRpYWxvZ1NlcnZpY2U6IERpYWxvZ1NlcnZpY2U7XG4gIHByb3RlY3RlZCBjZDogQ2hhbmdlRGV0ZWN0b3JSZWY7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGRpYWxvZ1JlZjogTWF0RGlhbG9nUmVmPE9Mb2FkRmlsdGVyRGlhbG9nQ29tcG9uZW50PixcbiAgICBASW5qZWN0KE1BVF9ESUFMT0dfREFUQSkgZGF0YTogT1RhYmxlRmlsdGVyc1N0YXR1c1tdLFxuICAgIHByb3RlY3RlZCBpbmplY3RvcjogSW5qZWN0b3JcbiAgKSB7XG4gICAgdGhpcy5sb2FkRmlsdGVycyhkYXRhKTtcbiAgICB0aGlzLmRpYWxvZ1NlcnZpY2UgPSB0aGlzLmluamVjdG9yLmdldDxEaWFsb2dTZXJ2aWNlPihEaWFsb2dTZXJ2aWNlIGFzIFR5cGU8RGlhbG9nU2VydmljZT4pO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNkID0gdGhpcy5pbmplY3Rvci5nZXQ8Q2hhbmdlRGV0ZWN0b3JSZWY+KENoYW5nZURldGVjdG9yUmVmIGFzIFR5cGU8Q2hhbmdlRGV0ZWN0b3JSZWY+KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBubyBwYXJlbnQgZm9ybVxuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuZmlsdGVyTGlzdC5zZWxlY3RlZE9wdGlvbnMgPSBuZXcgU2VsZWN0aW9uTW9kZWw8TWF0TGlzdE9wdGlvbj4oZmFsc2UpO1xuICB9XG5cbiAgbG9hZEZpbHRlcnMoZmlsdGVyczogT1RhYmxlRmlsdGVyc1N0YXR1c1tdKTogdm9pZCB7XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgfVxuXG4gIGdldFNlbGVjdGVkRmlsdGVyTmFtZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNlbGVjdGVkOiBNYXRMaXN0T3B0aW9uW10gPSB0aGlzLmZpbHRlckxpc3Quc2VsZWN0ZWRPcHRpb25zLnNlbGVjdGVkO1xuICAgIHJldHVybiBzZWxlY3RlZC5sZW5ndGggPyBzZWxlY3RlZFswXS52YWx1ZSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJlbW92ZUZpbHRlcihmaWx0ZXJOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmRpYWxvZ1NlcnZpY2UuY29uZmlybSgnQ09ORklSTScsICdUQUJMRS5ESUFMT0cuQ09ORklSTV9SRU1PVkVfRklMVEVSJykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICB0aGlzLm9uRGVsZXRlLmVtaXQoZmlsdGVyTmFtZSk7XG4gICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbiJdfQ==