import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, Injector, TemplateRef, ViewChild } from '@angular/core';
import { OMomentPipe } from '../../../../../pipes/o-moment.pipe';
import { DEFAULT_INPUTS_O_COMBO_RENDERER, OComboCustomRenderer } from '../o-combo-renderer.class';
export var DEFAULT_INPUTS_O_COMBO_RENDERER_DATE = tslib_1.__spread(DEFAULT_INPUTS_O_COMBO_RENDERER, [
    'format'
]);
var OComboRendererDateComponent = (function (_super) {
    tslib_1.__extends(OComboRendererDateComponent, _super);
    function OComboRendererDateComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.setComponentPipe();
        return _this;
    }
    OComboRendererDateComponent.prototype.setComponentPipe = function () {
        this.componentPipe = new OMomentPipe(this.injector);
    };
    OComboRendererDateComponent.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.pipeArguments = {
            format: this.format
        };
    };
    OComboRendererDateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'o-combo-renderer-date',
                    template: "<ng-template #templateref let-value=\"value\">\n  {{getComboData(value)}}\n</ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_COMBO_RENDERER_DATE
                }] }
    ];
    OComboRendererDateComponent.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    OComboRendererDateComponent.propDecorators = {
        templateref: [{ type: ViewChild, args: ['templateref', { read: TemplateRef, static: true },] }]
    };
    return OComboRendererDateComponent;
}(OComboCustomRenderer));
export { OComboRendererDateComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiby1jb21iby1yZW5kZXJlci1kYXRlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL29udGltaXplLXdlYi1uZ3gvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9pbnB1dC9jb21iby9jb21iby1yZW5kZXJlci9kYXRlL28tY29tYm8tcmVuZGVyZXItZGF0ZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFVLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFN0csT0FBTyxFQUF1QixXQUFXLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUN0RixPQUFPLEVBQUUsK0JBQStCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUVsRyxNQUFNLENBQUMsSUFBTSxvQ0FBb0Msb0JBQzVDLCtCQUErQjtJQUVsQyxRQUFRO0VBQ1QsQ0FBQztBQUVGO0lBTWlELHVEQUFvQjtJQVNuRSxxQ0FBc0IsUUFBa0I7UUFBeEMsWUFDRSxrQkFBTSxRQUFRLENBQUMsU0FFaEI7UUFIcUIsY0FBUSxHQUFSLFFBQVEsQ0FBVTtRQUV0QyxLQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQzs7SUFDMUIsQ0FBQztJQUVELHNEQUFnQixHQUFoQjtRQUNFLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRCxnREFBVSxHQUFWO1FBQ0UsaUJBQU0sVUFBVSxXQUFFLENBQUM7UUFFbkIsSUFBSSxDQUFDLGFBQWEsR0FBRztZQUNuQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07U0FDcEIsQ0FBQztJQUNKLENBQUM7O2dCQTlCRixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLHVCQUF1QjtvQkFDakMsdUdBQXFEO29CQUNyRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsTUFBTSxFQUFFLG9DQUFvQztpQkFDN0M7OztnQkFoQjRDLFFBQVE7Ozs4QkF3QmxELFNBQVMsU0FBQyxhQUFhLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7O0lBa0IvRCxrQ0FBQztDQUFBLEFBL0JELENBTWlELG9CQUFvQixHQXlCcEU7U0F6QlksMkJBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5qZWN0b3IsIE9uSW5pdCwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJTW9tZW50UGlwZUFyZ3VtZW50LCBPTW9tZW50UGlwZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3BpcGVzL28tbW9tZW50LnBpcGUnO1xuaW1wb3J0IHsgREVGQVVMVF9JTlBVVFNfT19DT01CT19SRU5ERVJFUiwgT0NvbWJvQ3VzdG9tUmVuZGVyZXIgfSBmcm9tICcuLi9vLWNvbWJvLXJlbmRlcmVyLmNsYXNzJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSU5QVVRTX09fQ09NQk9fUkVOREVSRVJfREFURSA9IFtcbiAgLi4uREVGQVVMVF9JTlBVVFNfT19DT01CT19SRU5ERVJFUixcbiAgLy8gZm9ybWF0IFtzdHJpbmddOiBkYXRlIGZvcm1hdC4gU2VlIE1vbWVudEpTIChodHRwOi8vbW9tZW50anMuY29tLykuXG4gICdmb3JtYXQnXG5dO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdvLWNvbWJvLXJlbmRlcmVyLWRhdGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vby1jb21iby1yZW5kZXJlci1kYXRlLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGlucHV0czogREVGQVVMVF9JTlBVVFNfT19DT01CT19SRU5ERVJFUl9EQVRFXG59KVxuZXhwb3J0IGNsYXNzIE9Db21ib1JlbmRlcmVyRGF0ZUNvbXBvbmVudCBleHRlbmRzIE9Db21ib0N1c3RvbVJlbmRlcmVyIGltcGxlbWVudHMgT25Jbml0IHtcblxuICBwcm90ZWN0ZWQgY29tcG9uZW50UGlwZTogT01vbWVudFBpcGU7XG4gIHByb3RlY3RlZCBwaXBlQXJndW1lbnRzOiBJTW9tZW50UGlwZUFyZ3VtZW50O1xuXG4gIHByb3RlY3RlZCBmb3JtYXQ6IHN0cmluZztcblxuICBAVmlld0NoaWxkKCd0ZW1wbGF0ZXJlZicsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KSBwdWJsaWMgdGVtcGxhdGVyZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHN1cGVyKGluamVjdG9yKTtcbiAgICB0aGlzLnNldENvbXBvbmVudFBpcGUoKTtcbiAgfVxuXG4gIHNldENvbXBvbmVudFBpcGUoKSB7XG4gICAgdGhpcy5jb21wb25lbnRQaXBlID0gbmV3IE9Nb21lbnRQaXBlKHRoaXMuaW5qZWN0b3IpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgLy8gQ2FsbGVkIGFmdGVyIHRoZSBjb25zdHJ1Y3RvciwgaW5pdGlhbGl6aW5nIGlucHV0IHByb3BlcnRpZXMsIGFuZCB0aGUgZmlyc3QgY2FsbCB0byBuZ09uQ2hhbmdlcy5cbiAgICB0aGlzLnBpcGVBcmd1bWVudHMgPSB7XG4gICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0XG4gICAgfTtcbiAgfVxufVxuIl19