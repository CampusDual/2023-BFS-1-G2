import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, Injector, TemplateRef, ViewChild } from '@angular/core';
import { OMomentPipe } from '../../../../../pipes/o-moment.pipe';
import { DEFAULT_INPUTS_O_LISTPICKER_RENDERER, OListPickerCustomRenderer } from '../o-list-picker-renderer.class';
export var DEFAULT_INPUTS_O_LISTPICKER_RENDERER_DATE = tslib_1.__spread(DEFAULT_INPUTS_O_LISTPICKER_RENDERER, [
    'format'
]);
var OListPickerRendererDateComponent = (function (_super) {
    tslib_1.__extends(OListPickerRendererDateComponent, _super);
    function OListPickerRendererDateComponent(injector) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.setComponentPipe();
        return _this;
    }
    OListPickerRendererDateComponent.prototype.setComponentPipe = function () {
        this.componentPipe = new OMomentPipe(this.injector);
    };
    OListPickerRendererDateComponent.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.pipeArguments = {
            format: this.format
        };
    };
    OListPickerRendererDateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'o-list-picker-renderer-date',
                    template: "<ng-template #templateref let-value=\"value\">\n  {{getListPickerValue(value)}}\n</ng-template>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    inputs: DEFAULT_INPUTS_O_LISTPICKER_RENDERER_DATE
                }] }
    ];
    OListPickerRendererDateComponent.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    OListPickerRendererDateComponent.propDecorators = {
        templateref: [{ type: ViewChild, args: ['templateref', { read: TemplateRef, static: true },] }]
    };
    return OListPickerRendererDateComponent;
}(OListPickerCustomRenderer));
export { OListPickerRendererDateComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiby1saXN0LXBpY2tlci1yZW5kZXJlci1kYXRlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL29udGltaXplLXdlYi1uZ3gvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9pbnB1dC9saXN0cGlja2VyL2xpc3RwaWNrZXItcmVuZGVyZXIvZGF0ZS9vLWxpc3QtcGlja2VyLXJlbmRlcmVyLWRhdGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBVSxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTdHLE9BQU8sRUFBdUIsV0FBVyxFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDdEYsT0FBTyxFQUFFLG9DQUFvQyxFQUFFLHlCQUF5QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFbEgsTUFBTSxDQUFDLElBQU0seUNBQXlDLG9CQUNqRCxvQ0FBb0M7SUFFdkMsUUFBUTtFQUNULENBQUM7QUFFRjtJQU1zRCw0REFBeUI7SUFTN0UsMENBQXNCLFFBQWtCO1FBQXhDLFlBQ0Usa0JBQU0sUUFBUSxDQUFDLFNBRWhCO1FBSHFCLGNBQVEsR0FBUixRQUFRLENBQVU7UUFFdEMsS0FBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7O0lBQzFCLENBQUM7SUFFRCwyREFBZ0IsR0FBaEI7UUFDRSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQscURBQVUsR0FBVjtRQUNFLGlCQUFNLFVBQVUsV0FBRSxDQUFDO1FBRW5CLElBQUksQ0FBQyxhQUFhLEdBQUc7WUFDbkIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1NBQ3BCLENBQUM7SUFDSixDQUFDOztnQkE5QkYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSw2QkFBNkI7b0JBQ3ZDLDZHQUEyRDtvQkFDM0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLE1BQU0sRUFBRSx5Q0FBeUM7aUJBQ2xEOzs7Z0JBaEI0QyxRQUFROzs7OEJBd0JsRCxTQUFTLFNBQUMsYUFBYSxFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFOztJQWtCL0QsdUNBQUM7Q0FBQSxBQS9CRCxDQU1zRCx5QkFBeUIsR0F5QjlFO1NBekJZLGdDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEluamVjdG9yLCBPbkluaXQsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSU1vbWVudFBpcGVBcmd1bWVudCwgT01vbWVudFBpcGUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9waXBlcy9vLW1vbWVudC5waXBlJztcbmltcG9ydCB7IERFRkFVTFRfSU5QVVRTX09fTElTVFBJQ0tFUl9SRU5ERVJFUiwgT0xpc3RQaWNrZXJDdXN0b21SZW5kZXJlciB9IGZyb20gJy4uL28tbGlzdC1waWNrZXItcmVuZGVyZXIuY2xhc3MnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9JTlBVVFNfT19MSVNUUElDS0VSX1JFTkRFUkVSX0RBVEUgPSBbXG4gIC4uLkRFRkFVTFRfSU5QVVRTX09fTElTVFBJQ0tFUl9SRU5ERVJFUixcbiAgLy8gZm9ybWF0IFtzdHJpbmddOiBkYXRlIGZvcm1hdC4gU2VlIE1vbWVudEpTIChodHRwOi8vbW9tZW50anMuY29tLykuXG4gICdmb3JtYXQnXG5dO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdvLWxpc3QtcGlja2VyLXJlbmRlcmVyLWRhdGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vby1saXN0LXBpY2tlci1yZW5kZXJlci1kYXRlLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGlucHV0czogREVGQVVMVF9JTlBVVFNfT19MSVNUUElDS0VSX1JFTkRFUkVSX0RBVEVcbn0pXG5leHBvcnQgY2xhc3MgT0xpc3RQaWNrZXJSZW5kZXJlckRhdGVDb21wb25lbnQgZXh0ZW5kcyBPTGlzdFBpY2tlckN1c3RvbVJlbmRlcmVyIGltcGxlbWVudHMgT25Jbml0IHtcblxuICBwcm90ZWN0ZWQgY29tcG9uZW50UGlwZTogT01vbWVudFBpcGU7XG4gIHByb3RlY3RlZCBwaXBlQXJndW1lbnRzOiBJTW9tZW50UGlwZUFyZ3VtZW50O1xuXG4gIHByb3RlY3RlZCBmb3JtYXQ6IHN0cmluZztcblxuICBAVmlld0NoaWxkKCd0ZW1wbGF0ZXJlZicsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KSBwdWJsaWMgdGVtcGxhdGVyZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHN1cGVyKGluamVjdG9yKTtcbiAgICB0aGlzLnNldENvbXBvbmVudFBpcGUoKTtcbiAgfVxuXG4gIHNldENvbXBvbmVudFBpcGUoKSB7XG4gICAgdGhpcy5jb21wb25lbnRQaXBlID0gbmV3IE9Nb21lbnRQaXBlKHRoaXMuaW5qZWN0b3IpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgLy8gQ2FsbGVkIGFmdGVyIHRoZSBjb25zdHJ1Y3RvciwgaW5pdGlhbGl6aW5nIGlucHV0IHByb3BlcnRpZXMsIGFuZCB0aGUgZmlyc3QgY2FsbCB0byBuZ09uQ2hhbmdlcy5cbiAgICB0aGlzLnBpcGVBcmd1bWVudHMgPSB7XG4gICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0XG4gICAgfTtcbiAgfVxufVxuIl19