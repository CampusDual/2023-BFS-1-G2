import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, Injector, TemplateRef, ViewChild, ViewEncapsulation, } from '@angular/core';
import { DateAdapter, MAT_DATE_LOCALE } from '@angular/material';
import moment from 'moment';
import { InputConverter } from '../../../../../decorators/input-converter';
import { MomentService } from '../../../../../services/moment.service';
import { OntimizeMomentDateAdapter } from '../../../../../shared/material/date/ontimize-moment-date-adapter';
import { Util } from '../../../../../util/util';
import { DEFAULT_INPUTS_O_TABLE_CELL_EDITOR, DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR, OBaseTableCellEditor, } from '../o-base-table-cell-editor.class';
export var DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE = tslib_1.__spread(DEFAULT_INPUTS_O_TABLE_CELL_EDITOR, [
    'format',
    'locale',
    'oStartView: start-view',
    'min',
    'max',
    'oTouchUi: touch-ui',
    'startAt: start-at',
    'filterDate: filter-date',
    'dateValueType: date-value-type'
]);
export var DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_DATE = tslib_1.__spread(DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR);
var OTableCellEditorDateComponent = (function (_super) {
    tslib_1.__extends(OTableCellEditorDateComponent, _super);
    function OTableCellEditorDateComponent(injector, momentDateAdapter) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.momentDateAdapter = momentDateAdapter;
        _this.format = 'L';
        _this.oStartView = 'month';
        _this.oTouchUi = false;
        _this._dateValueType = 'timestamp';
        _this.momentSrv = _this.injector.get(MomentService);
        return _this;
    }
    OTableCellEditorDateComponent.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        if (!this.locale) {
            this.locale = this.momentSrv.getLocale();
        }
        if (this.format) {
            this.momentDateAdapter.oFormat = this.format;
        }
        this.momentDateAdapter.setLocale(this.locale);
        if (this.startAt) {
            this.oStartAt = new Date(this.startAt);
        }
        if (this.min) {
            var date = new Date(this.min);
            var momentD = moment(date);
            if (momentD.isValid()) {
                this.oMinDate = date;
                this.minDateString = momentD.format(this.format);
            }
        }
        if (this.max) {
            var date = new Date(this.max);
            var momentD = moment(date);
            if (momentD.isValid()) {
                this.oMaxDate = date;
                this.maxDateString = momentD.format(this.format);
            }
        }
    };
    OTableCellEditorDateComponent.prototype.handleKeyup = function (event) {
        var oColumn = this.table.getOColumn(this.tableColumn.attr);
        if (!oColumn) {
            return;
        }
        if (!oColumn.editing && this.datepicker && this.datepicker.opened) {
            this.datepicker.close();
        }
        else {
            _super.prototype.handleKeyup.call(this, event);
        }
    };
    OTableCellEditorDateComponent.prototype.startEdition = function (data) {
        _super.prototype.startEdition.call(this, data);
        if (!this.startAt) {
            this.oStartAt = this.getCellData();
        }
    };
    OTableCellEditorDateComponent.prototype.getCellData = function () {
        var value = _super.prototype.getCellData.call(this);
        if (Util.isDefined(value)) {
            var result = value;
            var m = void 0;
            switch (this.dateValueType) {
                case 'string':
                    m = moment(value, this.format);
                    break;
                case 'date':
                    break;
                case 'iso-8601':
                case 'timestamp':
                default:
                    m = moment(value);
                    break;
            }
            if (Util.isDefined(m)) {
                result = m.toDate();
            }
            return result;
        }
        return value;
    };
    OTableCellEditorDateComponent.prototype.commitEdition = function () {
        if (!this.formControl.invalid) {
            this.oldValue = this._rowData[this.tableColumnAttr];
            this._rowData[this.tableColumnAttr] = this.getValueByValyType();
            if (!this.isSilentControl()) {
                this.endEdition(true);
                this.editionCommitted.emit(this._rowData);
            }
        }
    };
    OTableCellEditorDateComponent.prototype.getValueByValyType = function () {
        var result = this.formControl.value;
        var m = moment(this.formControl.value);
        switch (this.dateValueType) {
            case 'string':
                result = m.format(this.format);
                break;
            case 'date':
                result = new Date(result);
                break;
            case 'iso-8601':
                result = m.toISOString();
                break;
            case 'timestamp':
            default:
                result = m.valueOf();
                break;
        }
        return result;
    };
    OTableCellEditorDateComponent.prototype.onDateChange = function (event) {
        var isValid = event.value && event.value.isValid && event.value.isValid();
        var val = isValid ? event.value.valueOf() : event.value;
        var m = moment(val);
        switch (this.dateValueType) {
            case 'string':
                if (val) {
                    val = m.format(this.format);
                }
                break;
            case 'date':
                val = new Date(val);
                break;
            case 'iso-8601':
                val = m.toISOString();
                break;
            case 'timestamp':
            default:
                break;
        }
        this.formControl.setValue(val, {
            emitModelToViewChange: false,
            emitEvent: false
        });
    };
    OTableCellEditorDateComponent.prototype.openDatepicker = function (d) {
        this.datepicker = d;
        d.open();
    };
    Object.defineProperty(OTableCellEditorDateComponent.prototype, "dateValueType", {
        get: function () {
            return this._dateValueType;
        },
        set: function (val) {
            this._dateValueType = Util.convertToODateValueType(val);
        },
        enumerable: true,
        configurable: true
    });
    OTableCellEditorDateComponent.prototype.onClosed = function () {
        if (this.inputRef) {
            this.inputRef.nativeElement.focus();
        }
    };
    OTableCellEditorDateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'o-table-cell-editor-date',
                    template: "<ng-template #templateref let-cellvalue=\"cellvalue\" let-rowvalue=\"rowvalue\">\n  <div [formGroup]=\"formGroup\" class=\"o-table-cell-editor-date o-table-cell-editor\">\n    <mat-form-field floatLabel=\"never\" cdkFocusInitial>\n      <input #input matInput [id]=\"cellEditorId\" [placeholder]=\"getPlaceholder()\" [formControl]=\"formControl\"\n        [required]=\"orequired\" [matDatepicker]=\"d\" [matDatepickerFilter]=\"filterDate\"\n        (dateChange)=\"onDateChange($event)\" [min]=\"oMinDate\" [max]=\"oMaxDate\">\n\n      <mat-datepicker #d [startView]=\"oStartView\" [startAt]=\"oStartAt\" [touchUi]=\"oTouchUi\" (closed)=\"onClosed()\">\n      </mat-datepicker>\n\n      <span class=\"icon-btn\" (click)=\"openDatepicker(d)\" matSuffix>\n        <mat-icon svgIcon=\"ontimize:today\"></mat-icon>\n      </span>\n\n      <mat-error *oMatError=\"hasError('required')\">\n        {{ 'FORM_VALIDATION.REQUIRED' | oTranslate }}\n      </mat-error>\n      <mat-error *oMatError=\"hasError('matDatepickerParse')\">\n        {{ 'FORM_VALIDATION.DATE_PARSE' | oTranslate }} {{ format }}\n      </mat-error>\n      <mat-error *oMatError=\"hasError('matDatepickerFilter')\">\n        {{ 'FORM_VALIDATION.DATE_FILTER' | oTranslate }}\n      </mat-error>\n      <mat-error *oMatError=\"hasError('matDatepickerMin')\">\n        {{ 'FORM_VALIDATION.DATE_MIN' | oTranslate }} {{ minDateString }}\n      </mat-error>\n      <mat-error *oMatError=\"hasError('matDatepickerMax')\">\n        {{ 'FORM_VALIDATION.DATE_MAX' | oTranslate }} {{ maxDateString }}\n      </mat-error>\n      <mat-error *ngFor=\"let oError of getActiveOErrors()\">\n        {{ getErrorText(oError) }}\n      </mat-error>\n    </mat-form-field>\n  </div>\n</ng-template>\n",
                    inputs: DEFAULT_INPUTS_O_TABLE_CELL_EDITOR_DATE,
                    outputs: DEFAULT_OUTPUTS_O_TABLE_CELL_EDITOR_DATE,
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        { provide: DateAdapter, useClass: OntimizeMomentDateAdapter, deps: [MAT_DATE_LOCALE] }
                    ],
                    styles: [""]
                }] }
    ];
    OTableCellEditorDateComponent.ctorParameters = function () { return [
        { type: Injector },
        { type: DateAdapter }
    ]; };
    OTableCellEditorDateComponent.propDecorators = {
        templateref: [{ type: ViewChild, args: ['templateref', { read: TemplateRef, static: true },] }]
    };
    tslib_1.__decorate([
        InputConverter(),
        tslib_1.__metadata("design:type", Boolean)
    ], OTableCellEditorDateComponent.prototype, "oTouchUi", void 0);
    return OTableCellEditorDateComponent;
}(OBaseTableCellEditor));
export { OTableCellEditorDateComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiby10YWJsZS1jZWxsLWVkaXRvci1kYXRlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL29udGltaXplLXdlYi1uZ3gvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy90YWJsZS9jb2x1bW4vY2VsbC1lZGl0b3IvZGF0ZS9vLXRhYmxlLWNlbGwtZWRpdG9yLWRhdGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFFVCxRQUFRLEVBRVIsV0FBVyxFQUNYLFNBQVMsRUFDVCxpQkFBaUIsR0FDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFdBQVcsRUFBRSxlQUFlLEVBQTBDLE1BQU0sbUJBQW1CLENBQUM7QUFDekcsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBRTVCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUMzRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDdkUsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sa0VBQWtFLENBQUM7QUFHN0csT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hELE9BQU8sRUFDTCxrQ0FBa0MsRUFDbEMsbUNBQW1DLEVBQ25DLG9CQUFvQixHQUNyQixNQUFNLG1DQUFtQyxDQUFDO0FBRTNDLE1BQU0sQ0FBQyxJQUFNLHVDQUF1QyxvQkFDL0Msa0NBQWtDO0lBQ3JDLFFBQVE7SUFDUixRQUFRO0lBQ1Isd0JBQXdCO0lBQ3hCLEtBQUs7SUFDTCxLQUFLO0lBQ0wsb0JBQW9CO0lBQ3BCLG1CQUFtQjtJQUNuQix5QkFBeUI7SUFJekIsZ0NBQWdDO0VBQ2pDLENBQUM7QUFFRixNQUFNLENBQUMsSUFBTSx3Q0FBd0Msb0JBQ2hELG1DQUFtQyxDQUN2QyxDQUFDO0FBRUY7SUFhbUQseURBQW9CO0lBd0JyRSx1Q0FDWSxRQUFrQixFQUNsQixp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LGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxTQUFTLEVBQUU7d0JBQ1QsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSx5QkFBeUIsRUFBRSxJQUFJLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRTtxQkFDdkY7O2lCQUNGOzs7Z0JBcERDLFFBQVE7Z0JBTUQsV0FBVzs7OzhCQWtEakIsU0FBUyxTQUFDLGFBQWEsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs7SUFRN0Q7UUFEQyxjQUFjLEVBQUU7O21FQUNTO0lBaUw1QixvQ0FBQztDQUFBLEFBeE1ELENBYW1ELG9CQUFvQixHQTJMdEU7U0EzTFksNkJBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0b3IsXG4gIE9uSW5pdCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZUFkYXB0ZXIsIE1BVF9EQVRFX0xPQ0FMRSwgTWF0RGF0ZXBpY2tlciwgTWF0RGF0ZXBpY2tlcklucHV0RXZlbnQgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5cbmltcG9ydCB7IElucHV0Q29udmVydGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZGVjb3JhdG9ycy9pbnB1dC1jb252ZXJ0ZXInO1xuaW1wb3J0IHsgTW9tZW50U2VydmljZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3NlcnZpY2VzL21vbWVudC5zZXJ2aWNlJztcbmltcG9ydCB7IE9udGltaXplTW9tZW50RGF0ZUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9zaGFyZWQvbWF0ZXJpYWwvZGF0ZS9vbnRpbWl6ZS1tb21lbnQtZGF0ZS1hZGFwdGVyJztcbmltcG9ydCB7IERhdGVGaWx0ZXJGdW5jdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3R5cGVzL2RhdGUtZmlsdGVyLWZ1bmN0aW9uLnR5cGUnO1xuaW1wb3J0IHsgT0RhdGVWYWx1ZVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi90eXBlcy9vLWRhdGUtdmFsdWUudHlwZSc7XG5pbXBvcnQgeyBVdGlsIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbC91dGlsJztcbmltcG9ydCB7XG4gIERFRkFVTFRfSU5QVVRTX09fVEFCTEVfQ0VMTF9FRElUT1IsXG4gIERFRkFVTFRfT1VUUFVUU19PX1RBQkxFX0NFTExfRURJVE9SLFxuICBPQmFzZVRhYmxlQ2VsbEVkaXRvcixcbn0gZnJvbSAnLi4vby1iYXNlLXRhYmxlLWNlbGwtZWRpdG9yLmNsYXNzJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfSU5QVVRTX09fVEFCTEVfQ0VMTF9FRElUT1JfREFURSA9IFtcbiAgLi4uREVGQVVMVF9JTlBVVFNfT19UQUJMRV9DRUxMX0VESVRPUixcbiAgJ2Zvcm1hdCcsXG4gICdsb2NhbGUnLFxuICAnb1N0YXJ0Vmlldzogc3RhcnQtdmlldycsXG4gICdtaW4nLFxuICAnbWF4JyxcbiAgJ29Ub3VjaFVpOiB0b3VjaC11aScsXG4gICdzdGFydEF0OiBzdGFydC1hdCcsXG4gICdmaWx0ZXJEYXRlOiBmaWx0ZXItZGF0ZScsXG4gIC8vIHZhbHVlLXR5cGUgW3RpbWVzdGFtcHxzdHJpbmddOiB0eXBlIG11c3QgYmUgZGVmaW5lZCB0byBiZSBhYmxlIHRvIHNhdmUgaXRzIHZhbHVlLFxuICAvLyBlLmcuIGNsYXNzaWMgb250aW1pemUgc2VydmVyIGRhdGVzIGNvbWUgYXMgdGltZXN0YW1wcyAobnVtYmVyKSwgYnV0IHRvIGJlIGFibGUgdG8gc2F2ZSB0aGVtIHRoZXkgaGF2ZSB0byBiZSBzZW5kIGFzIHN0cmluZ3Mgd2l0aFxuICAvLyB0aGUgZm9ybWF0ICdZWVlZLU1NLUREIEhIOm1tOnNzJ0RlZmF1bHQ6IHRpbWVzdGFtcC5cbiAgJ2RhdGVWYWx1ZVR5cGU6IGRhdGUtdmFsdWUtdHlwZSdcbl07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX09VVFBVVFNfT19UQUJMRV9DRUxMX0VESVRPUl9EQVRFID0gW1xuICAuLi5ERUZBVUxUX09VVFBVVFNfT19UQUJMRV9DRUxMX0VESVRPUlxuXTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnby10YWJsZS1jZWxsLWVkaXRvci1kYXRlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL28tdGFibGUtY2VsbC1lZGl0b3ItZGF0ZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL28tdGFibGUtY2VsbC1lZGl0b3ItZGF0ZS5jb21wb25lbnQuc2NzcyddLFxuICBpbnB1dHM6IERFRkFVTFRfSU5QVVRTX09fVEFCTEVfQ0VMTF9FRElUT1JfREFURSxcbiAgb3V0cHV0czogREVGQVVMVF9PVVRQVVRTX09fVEFCTEVfQ0VMTF9FRElUT1JfREFURSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByb3ZpZGVyczogW1xuICAgIHsgcHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBPbnRpbWl6ZU1vbWVudERhdGVBZGFwdGVyLCBkZXBzOiBbTUFUX0RBVEVfTE9DQUxFXSB9XG4gIF1cbn0pXG5cbmV4cG9ydCBjbGFzcyBPVGFibGVDZWxsRWRpdG9yRGF0ZUNvbXBvbmVudCBleHRlbmRzIE9CYXNlVGFibGVDZWxsRWRpdG9yIGltcGxlbWVudHMgT25Jbml0IHtcblxuICBAVmlld0NoaWxkKCd0ZW1wbGF0ZXJlZicsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KSBwdWJsaWMgdGVtcGxhdGVyZWY6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgZm9ybWF0OiBzdHJpbmcgPSAnTCc7XG4gIHByb3RlY3RlZCBsb2NhbGU6IHN0cmluZztcbiAgb1N0YXJ0VmlldzogJ21vbnRoJyB8ICd5ZWFyJyA9ICdtb250aCc7XG4gIHByb3RlY3RlZCBtaW46IHN0cmluZztcbiAgcHJvdGVjdGVkIG1heDogc3RyaW5nO1xuICBASW5wdXRDb252ZXJ0ZXIoKVxuICBvVG91Y2hVaTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgc3RhcnRBdDogc3RyaW5nO1xuICBmaWx0ZXJEYXRlOiBEYXRlRmlsdGVyRnVuY3Rpb247XG4gIF9kYXRlVmFsdWVUeXBlOiBPRGF0ZVZhbHVlVHlwZSA9ICd0aW1lc3RhbXAnO1xuXG4gIG9TdGFydEF0OiBEYXRlO1xuICBvTWluRGF0ZTogRGF0ZTtcbiAgb01heERhdGU6IERhdGU7XG5cbiAgcHJpdmF0ZSBtb21lbnRTcnY6IE1vbWVudFNlcnZpY2U7XG4gIG1pbkRhdGVTdHJpbmc6IHN0cmluZztcbiAgbWF4RGF0ZVN0cmluZzogc3RyaW5nO1xuXG4gIHByb3RlY3RlZCBkYXRlcGlja2VyOiBNYXREYXRlcGlja2VyPERhdGU+O1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByb3RlY3RlZCBtb21lbnREYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8T250aW1pemVNb21lbnREYXRlQWRhcHRlcj5cbiAgKSB7XG4gICAgc3VwZXIoaW5qZWN0b3IpO1xuICAgIHRoaXMubW9tZW50U3J2ID0gdGhpcy5pbmplY3Rvci5nZXQoTW9tZW50U2VydmljZSk7XG4gIH1cblxuICBpbml0aWFsaXplKCk6IHZvaWQge1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICBpZiAoIXRoaXMubG9jYWxlKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9IHRoaXMubW9tZW50U3J2LmdldExvY2FsZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb3JtYXQpIHtcbiAgICAgICh0aGlzLm1vbWVudERhdGVBZGFwdGVyIGFzIGFueSkub0Zvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIH1cblxuICAgIHRoaXMubW9tZW50RGF0ZUFkYXB0ZXIuc2V0TG9jYWxlKHRoaXMubG9jYWxlKTtcbiAgICBpZiAodGhpcy5zdGFydEF0KSB7XG4gICAgICB0aGlzLm9TdGFydEF0ID0gbmV3IERhdGUodGhpcy5zdGFydEF0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW4pIHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aGlzLm1pbik7XG4gICAgICBjb25zdCBtb21lbnREID0gbW9tZW50KGRhdGUpO1xuICAgICAgaWYgKG1vbWVudEQuaXNWYWxpZCgpKSB7XG4gICAgICAgIHRoaXMub01pbkRhdGUgPSBkYXRlO1xuICAgICAgICB0aGlzLm1pbkRhdGVTdHJpbmcgPSBtb21lbnRELmZvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF4KSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGhpcy5tYXgpO1xuICAgICAgY29uc3QgbW9tZW50RCA9IG1vbWVudChkYXRlKTtcbiAgICAgIGlmIChtb21lbnRELmlzVmFsaWQoKSkge1xuICAgICAgICB0aGlzLm9NYXhEYXRlID0gZGF0ZTtcbiAgICAgICAgdGhpcy5tYXhEYXRlU3RyaW5nID0gbW9tZW50RC5mb3JtYXQodGhpcy5mb3JtYXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBoYW5kbGVLZXl1cChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IG9Db2x1bW4gPSB0aGlzLnRhYmxlLmdldE9Db2x1bW4odGhpcy50YWJsZUNvbHVtbi5hdHRyKTtcbiAgICBpZiAoIW9Db2x1bW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFvQ29sdW1uLmVkaXRpbmcgJiYgdGhpcy5kYXRlcGlja2VyICYmIHRoaXMuZGF0ZXBpY2tlci5vcGVuZWQpIHtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlci5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5oYW5kbGVLZXl1cChldmVudCk7XG4gICAgfVxuICB9XG5cbiAgc3RhcnRFZGl0aW9uKGRhdGE6IGFueSkge1xuICAgIHN1cGVyLnN0YXJ0RWRpdGlvbihkYXRhKTtcbiAgICBpZiAoIXRoaXMuc3RhcnRBdCkge1xuICAgICAgdGhpcy5vU3RhcnRBdCA9IHRoaXMuZ2V0Q2VsbERhdGEoKTtcbiAgICB9XG4gIH1cblxuICBnZXRDZWxsRGF0YSgpOiBhbnkge1xuICAgIGNvbnN0IHZhbHVlID0gc3VwZXIuZ2V0Q2VsbERhdGEoKTtcbiAgICBpZiAoVXRpbC5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBsZXQgbTtcbiAgICAgIHN3aXRjaCAodGhpcy5kYXRlVmFsdWVUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgbSA9IG1vbWVudCh2YWx1ZSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXNvLTg2MDEnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG0gPSBtb21lbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKFV0aWwuaXNEZWZpbmVkKG0pKSB7XG4gICAgICAgIHJlc3VsdCA9IG0udG9EYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb21taXRFZGl0aW9uKCkge1xuICAgIC8vICF0aGlzLmRhdGVwaWNrZXIub3BlbmVkICYmXG4gICAgaWYgKCF0aGlzLmZvcm1Db250cm9sLmludmFsaWQpIHtcbiAgICAgIHRoaXMub2xkVmFsdWUgPSB0aGlzLl9yb3dEYXRhW3RoaXMudGFibGVDb2x1bW5BdHRyXTtcbiAgICAgIHRoaXMuX3Jvd0RhdGFbdGhpcy50YWJsZUNvbHVtbkF0dHJdID0gdGhpcy5nZXRWYWx1ZUJ5VmFseVR5cGUoKTtcbiAgICAgIGlmICghdGhpcy5pc1NpbGVudENvbnRyb2woKSkge1xuICAgICAgICB0aGlzLmVuZEVkaXRpb24odHJ1ZSk7XG4gICAgICAgIHRoaXMuZWRpdGlvbkNvbW1pdHRlZC5lbWl0KHRoaXMuX3Jvd0RhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRWYWx1ZUJ5VmFseVR5cGUoKTogYW55IHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICBjb25zdCBtID0gbW9tZW50KHRoaXMuZm9ybUNvbnRyb2wudmFsdWUpO1xuICAgIHN3aXRjaCAodGhpcy5kYXRlVmFsdWVUeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXN1bHQgPSBtLmZvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaXNvLTg2MDEnOlxuICAgICAgICByZXN1bHQgPSBtLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGltZXN0YW1wJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlc3VsdCA9IG0udmFsdWVPZigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIG9uRGF0ZUNoYW5nZShldmVudDogTWF0RGF0ZXBpY2tlcklucHV0RXZlbnQ8YW55Pikge1xuICAgIGNvbnN0IGlzVmFsaWQgPSBldmVudC52YWx1ZSAmJiBldmVudC52YWx1ZS5pc1ZhbGlkICYmIGV2ZW50LnZhbHVlLmlzVmFsaWQoKTtcbiAgICBsZXQgdmFsID0gaXNWYWxpZCA/IGV2ZW50LnZhbHVlLnZhbHVlT2YoKSA6IGV2ZW50LnZhbHVlO1xuICAgIGNvbnN0IG0gPSBtb21lbnQodmFsKTtcbiAgICBzd2l0Y2ggKHRoaXMuZGF0ZVZhbHVlVHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgIHZhbCA9IG0uZm9ybWF0KHRoaXMuZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICB2YWwgPSBuZXcgRGF0ZSh2YWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lzby04NjAxJzpcbiAgICAgICAgdmFsID0gbS50b0lTT1N0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbCwge1xuICAgICAgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlOiBmYWxzZSxcbiAgICAgIGVtaXRFdmVudDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIG9wZW5EYXRlcGlja2VyKGQ6IE1hdERhdGVwaWNrZXI8RGF0ZT4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIgPSBkO1xuICAgIGQub3BlbigpO1xuICB9XG5cbiAgc2V0IGRhdGVWYWx1ZVR5cGUodmFsOiBhbnkpIHtcbiAgICB0aGlzLl9kYXRlVmFsdWVUeXBlID0gVXRpbC5jb252ZXJ0VG9PRGF0ZVZhbHVlVHlwZSh2YWwpO1xuICB9XG5cbiAgZ2V0IGRhdGVWYWx1ZVR5cGUoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVZhbHVlVHlwZTtcbiAgfVxuXG4gIG9uQ2xvc2VkKCkge1xuICAgIGlmICh0aGlzLmlucHV0UmVmKSB7XG4gICAgICB0aGlzLmlucHV0UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==